# 后端实现说明（Gin + GORM + MySQL）

本文档描述 `backend` 目录内后端服务的总体设计、目录结构建议、配置项、数据库模型、鉴权方案、接口规范以及与浏览器插件的联调方式。

## 1. 目标与范围
- 提供统一鉴权：支持“游客登录（guest）”与“正式账号登录（email/password）”。
- 提供 AI 转发接口：将客户端请求安全地代理到外部大模型服务（参考 `backend/local.yaml` 中的 Relay 配置），支持流式响应。
- 提供基础运维能力：健康检查、结构化日志、限流与审计。
- 面向 Chrome/Edge/Firefox 插件与后续 Web/桌面端统一使用。

## 2. 技术栈与运行环境
- 语言/运行时：Go 1.21+（建议 1.22）
- Web 框架：Gin
- ORM：GORM
- 数据库：MySQL 8.x（开发可用 SQLite 作为 fallback）
- 配置：YAML（`backend/local.yaml`），机密通过环境变量注入
- 日志：zap（或 log/slog）
- 依赖管理：Go modules

## 3. 目录结构建议
```
backend/
  cmd/
    server/
      main.go                 # 入口：载入配置、初始化依赖、启动 HTTP Server
  internal/
    config/
      config.go               # 读取合并 YAML + env（如 JWT_SECRET、DB_DSN）
    server/
      http.go                 # Gin Engine、路由注册、优雅关停
    middleware/
      cors.go                 # CORS、Chrome 扩展白名单
      auth.go                 # JWT 校验，注入用户上下文
      ratelimit.go            # 令牌桶/滑动窗口限流（IP、用户）
      requestid.go            # X-Request-ID
      recovery.go             # Panic 恢复
    model/
      user.go                 # User/Guest
      refresh_token.go        # RefreshToken（可选）
      usage_log.go            # 用量/审计日志
    repository/
      user_repo.go
      token_repo.go
      usage_repo.go
    service/
      auth_service.go
      relay_service.go
    handler/
      auth_handler.go         # /api/v1/auth/*
      relay_handler.go        # /api/v1/relay/*（代理到大模型）
      health_handler.go       # /api/v1/healthz
  pkg/
    response/response.go     # 统一返回结构 & 错误码
  local.yaml                  # 本地配置（非机密，机密走 env）
  go.mod / go.sum
```

## 4. 配置项（`backend/local.yaml` + 环境变量）
YAML 建议结构（保持向后兼容当前已有的 `Relay` 段）：
```yaml
Server:
  Address: ":8080"           # 监听地址
  Mode: "release"            # gin: release | debug
  CORS:
    AllowOrigins: ["http://localhost:5173", "chrome-extension://*"]
    AllowHeaders: ["Authorization", "Content-Type", "X-Request-ID"]
DB:
  Driver: "mysql"             # "mysql" | "sqlite"
  DSN: "${DB_DSN}"            # 从环境变量注入，例：user:pass@tcp(127.0.0.1:3306)/lingolink?... 
JWT:
  Secret: "${JWT_SECRET}"     # 从环境变量注入
  AccessTTL: "1h"             # 访问令牌有效期
  RefreshTTL: "720h"          # 刷新令牌有效期（30 天）
Guest:
  DailyLimit: 50               # 游客每日请求次数或令牌数限制（示意）
Relay:
  Model: DeepSeek-V3
  Url: https://api.modelarts-maas.com/v1/chat/completions
  ApiKey: ${RELAY_API_KEY}     # 建议改为环境变量注入
  Temperature: 0
  Stream: true
Mysql:
  Path: "127.0.0.1"
  Port: "3306"
  Dbname: "click-translate"
  Username: "root"
  Password: "123456"
  Config: charset=utf8mb4&parseTime=True&loc=Local
  MaxIdleConns: 10
  MaxOpenConns: 100
  LogMode: error
  LogZap: true
``` 
> `Mysql` 段可直接填写主机/端口/库名/账号/密码等，加载时会自动拼装成 `mysql` DSN。如果只有 `Mysql` 且没有 `DB` 段，服务会默认使用该 MySQL，连接池参数会传递 `MaxIdleConns` / `MaxOpenConns`。
>
> 新表结构已在 `backend/sql/schema.sql` 中列出，执行 `mysql -u root -p < backend/sql/schema.sql`（或自行在数据库中新建 `click-translate` 并建表）后，`users` / `refresh_tokens` / `usage_logs` 会和 GORM 模型保持一致，用于记录登录与转发行为。
> 安全建议：不要把真实 API Key 写入仓库文件。将 `RELAY_API_KEY`、`JWT_SECRET`、`DB_DSN` 等敏感信息只放在本机/服务器环境变量或密钥管理服务中。

## 5. 数据库模型
- `users`
  - `id` bigint PK
  - `email` varchar(255) unique nullable（游客可为空）
  - `password_hash` varchar(255) nullable（游客为空）
  - `provider` enum('guest','local','oauth') default 'guest'
  - `is_guest` bool（冗余加速查询，或仅用 provider）
  - `display_name` varchar(255) nullable
  - `created_at` / `updated_at` / `last_login_at`

- `refresh_tokens`（可选，若实现可撤销会话）
  - `id` bigint PK
  - `user_id` bigint FK
  - `jti` char(36) unique
  - `expires_at` datetime
  - `revoked` bool

- `usage_logs`
  - `id` bigint PK
  - `user_id` bigint FK nullable（游客可空或指向游客用户）
  - `route` varchar(128)（如 /api/v1/relay/chat/completions）
  - `tokens` int nullable（若可获知）
  - `prompt_chars` int / `completion_chars` int（仅记录规模，不落盘原文）
  - `cost` decimal(10,4) nullable
  - `created_at` datetime

> 迁移：开发阶段可用 GORM AutoMigrate，上线前建议改用 goose/atlas 等版本化迁移工具。

## 6. 鉴权与会话
- 令牌：JWT（HS256）。
  - Access Token：默认 1 小时；`sub`=userID，`typ`="access"。
  - Refresh Token：默认 30 天；`typ`="refresh"，`jti` 用于服务端撤销（可选）。
- 游客登录：
  - 客户端可传 `device_id`（可选用于简单风控）；服务端创建 `provider=guest` 的用户或复用已有游客用户；签发短时 Access Token（可设 12–24 小时），可选签发 Refresh Token。
  - 绑定每日/全局限流策略（IP + 设备 + 账号）。
- 正式登录：
  - `email + password`；存储 `password_hash`（建议 bcrypt/argon2id）。
  - 支持注册/登录/刷新/登出。

## 7. 统一返回结构
```json
{
  "code": 0,                 // 0 成功；非 0 为业务错误码
  "message": "ok",
  "data": { ... },          // 具体数据
  "request_id": "..."       // 便于排障
}
```

## 8. 接口定义（v1）
基准路径：`/api/v1`

### 8.1 健康检查
- `GET /healthz` → 200 OK，返回 `{status:"ok"}`。

### 8.2 鉴权
- `POST /auth/guest-login`
  - Req Body：`{ "device_id": "<可选>", "ext_version": "<可选>" }`
  - Resp：`{ access_token, refresh_token?, expires_in }`

- `POST /auth/register`
  - Req：`{ "email": "...", "password": "...", "display_name": "可选" }`
  - Resp：`{ user: {id, email, display_name}, access_token, refresh_token }`

- `POST /auth/login`
  - Req：`{ "email": "...", "password": "..." }`
  - Resp：同上。

- `POST /auth/refresh`
  - Req：`{ "refresh_token": "..." }`
  - Resp：`{ access_token, refresh_token }`

- `GET /auth/me`（需要 `Authorization: Bearer <token>`）
  - Resp：`{ id, email, display_name, provider, created_at }`

错误码建议：
- `10001` 参数错误；`10002` 认证失败；`10003` 频率受限；`10004` 权限不足；`10005` 外部服务错误。

### 8.3 AI 转发（兼容 OpenAI Chat Completions 风格）
- `POST /relay/chat/completions`
  - Header：
    - `Authorization: Bearer <access_token>`
    - `Accept: text/event-stream`（当 `stream=true` 时）
  - Req Body（示例）：
    ```json
    {
      "model": "DeepSeek-V3",
      "stream": true,
      "messages": [
        {"role":"system","content":"You are a helpful assistant."},
        {"role":"user","content":"你好"}
      ]
    }
    ```
  - 行为：
    - 服务端根据 `Relay` 配置将请求转发到外部接口（见 `backend/local.yaml`）。
    - 透传/转换必要字段；屏蔽/覆盖客户端传入的 `api_key` 等敏感项。
    - 记录用量日志（不落盘完整 Prompt，记录长度/令牌数即可）。
    - 支持 SSE 流式转发：逐块读取上游响应并写回客户端（`Content-Type: text/event-stream`，`Transfer-Encoding: chunked`）。
  - 限制：
    - 游客用户按日限额；超过阈值返回 `429` + 业务码 `10003`。
    - 正式用户可有更高配额，后续可按套餐计费。

### 8.4 示例 cURL
```bash
# 游客登录
curl -sX POST http://localhost:8080/api/v1/auth/guest-login \
  -H 'Content-Type: application/json' \
  -d '{"device_id":"dev-123"}'

# 带 Token 访问流式对话
curl -N -sX POST http://localhost:8080/api/v1/relay/chat/completions \
  -H 'Authorization: Bearer <ACCESS_TOKEN>' \
  -H 'Content-Type: application/json' \
  -H 'Accept: text/event-stream' \
  -d '{"model":"DeepSeek-V3","stream":true,"messages":[{"role":"user","content":"你好"}]}'
```

## 9. 中间件与横切关注点
- CORS：允许本地 Dev 站点与 `chrome-extension://*` 源。
- 日志：结构化日志（traceID/requestID，用户 ID、路由、耗时）。
- 限流：游客按 IP + 设备 + 用户多维度限流；正式用户按用户限流。
- 恢复：Panic 恢复，避免服务宕机。
- 观测：/metrics（可选，Prometheus）。

## 10. 安全与合规
- 机密管理：`RELAY_API_KEY`、`JWT_SECRET`、`DB_DSN` 一律走环境变量；避免写入 Git。
- 最小化日志：不记录完整 Prompt/Completion，仅记录长度/令牌数与耗时。
- 输入校验：对 `messages` 长度与内容进行基本校验，防止过大请求压垮服务。
- 超时与重试：转发上游请求设置合理超时（如 60s），失败重试上限（如 1 次）。
- 账号安全：密码哈希使用 bcrypt（cost 12+）或 argon2id；登录尝试失败次数限制。

## 11. 本地开发运行
1) 准备环境变量（示例）：
```bash
export DB_DSN="user:pass@tcp(127.0.0.1:3306)/lingolink?charset=utf8mb4&parseTime=True&loc=Local"
export JWT_SECRET="<随机 32+ 字符>"
export RELAY_API_KEY="<外部服务Key>"
```
2) 编辑 `backend/local.yaml`（保留 Relay 段，去除明文 Key，使用 `${RELAY_API_KEY}`）。

3) 启动 MySQL 并创建数据库 `lingolink`。

4) 运行：
```bash
cd backend && go run ./cmd/server
```

## 12. 插件联调说明
- 初始化：插件启动时调用 `POST /api/v1/auth/guest-login` 获取游客 `access_token`（必要时带上 `device_id` 与扩展版本）。
- 用户登录：用户输入邮箱/密码后切换为正式身份，改用 `access_token` 访问。
- 发起对话：插件将 Chat Completions 风格请求发送至 `/api/v1/relay/chat/completions`，若希望流式显示，则携带 `Accept: text/event-stream` 并读取 SSE 片段。
- 失败处理：
  - 401/403：令牌过期或无效 → 引导刷新或重新登录。
  - 429：触发限流 → 提示稍后再试或升级账号。

### 12.1 本地调试与环境化 Base URL

要把后端与扩展打通，先在本地调通接口即可。默认 `src/api/index.ts` 中的 `baseUrl` 指向 `https://api.mywords.cc`（即线上接口），但本地调试时需指向 `backend` 服务。推荐将其改为以下环境感知形式，在开发环境把后端地址注入：

```ts
const baseUrl = import.meta.env.VITE_API_BASE_URL ?? "https://api.mywords.cc";
```

配合 Vite 的环境变量机制，本地调试时先在一终端启动后端：

```bash
cd backend
go run ./cmd/server
```

然后在扩展目录设定 baseUrl：

```bash
VITE_API_BASE_URL=http://localhost:8080 npm run dev:chrome
```

这个命令会让 Vite 在开发模式下把 `VITE_API_BASE_URL` 注入到 `import.meta.env`，后续的所有 API 本地请求都会走本地 `backend`。确认 `backend/local.yaml` 中 `Server.CORS.AllowOrigins` 已包含 `chrome-extension://*` 以便插件可以读写本地接口。

如果需要加载打包后的扩展，`npm run build:chrome` 会把文件输出到 `dist/chrome`，你可以用 Chrome 的“加载已解压的扩展”指向该目录，依然可以在运行前通过 `cross-env VITE_API_BASE_URL=http://localhost:8080 npm run build:chrome` 在构建期切换 Base URL。

## 13. 实现要点与伪代码
- 转发（流式）核心思路：
  1) 构造上游 HTTP 请求（填充 `Authorization: Bearer ${RELAY_API_KEY}`）。
  2) `Do(req)` 后将响应头 `Content-Type`、`Cache-Control` 等透传；逐块读上游 `Body` 并写入下游 `Writer`；`Flush()` 刷新。
  3) 统计字节数/片段数，写入 `usage_logs`。

```go
// 伪代码：将请求转发到外部大模型（支持 SSE）
func (h *RelayHandler) ChatCompletions(c *gin.Context) {
    ctx := c.Request.Context()
    // 1) 读取入参、执行业务限流与权限校验
    // 2) 构造上游请求（覆盖/注入安全字段）
    req, _ := http.NewRequestWithContext(ctx, http.MethodPost, cfg.Relay.Url, c.Request.Body)
    req.Header.Set("Authorization", "Bearer "+os.Getenv("RELAY_API_KEY"))
    req.Header.Set("Content-Type", "application/json")

    resp, err := h.client.Do(req)
    if err != nil { /* 返回外部服务错误 */ }
    defer resp.Body.Close()

    // 3) 透传必要响应头并流式复制
    for k, v := range resp.Header { c.Writer.Header()[k] = v }
    c.Status(resp.StatusCode)
    buf := make([]byte, 8192)
    for {
        n, rerr := resp.Body.Read(buf)
        if n > 0 { c.Writer.Write(buf[:n]); c.Writer.Flush() }
        if rerr != nil { break }
    }
}
```

## 14. 后续迭代清单
- 第一期（MVP）
  - 游客登录 + 正式登录（带刷新）。
  - 转发接口（含流式）。
  - 基础限流、审计日志、健康检查。
- 第二期
  - 用量统计面板与配额策略。
  - OAuth（GitHub/Google）登录。
  - 分角色/套餐的模型路由与开关。
- 第三期
  - 计费/订单系统；更细粒度策略（对话数、Token 数）。
  - 灰度/熔断/重试策略优化；多上游模型路由。

——
说明：当前仓库 `backend/local.yaml` 已存在 `Relay` 段配置。为安全起见，请将其中的 `ApiKey` 改为引用环境变量（如 `${RELAY_API_KEY}`），并在部署环境注入真实值。
